import contextlib
import dataclasses
import textwrap
import typing

import commonmark

class Writer:
    def __init__(self) -> None:
        self._f: typing.TextIO | None = None
        self._indent = 0
        self._allowed_blanks = 0

    def generate(self, f: typing.TextIO | None = None) -> None:
        self._f = f
        self.go()

    def go(self) -> None:
        raise NotImplementedError

    def print(self, *args, **kwargs) -> typing.ContextManager[None]:
        blank = len(args) == 0 or not args[0]

        if blank:
            self._allowed_blanks -= 1
        else:
            print(' ' * self._indent, end='', file=self._f)
            self._allowed_blanks = 1

        if not blank or self._allowed_blanks >= 0:
            print(*args, **kwargs, file=self._f)

        return self.indent()

    @contextlib.contextmanager
    def indent(self) -> typing.Iterator[None]:
        indent = self._indent
        try:
            self._indent += 4
            self._allowed_blanks = 0
            yield
        finally:
            self._indent = indent

    def generated_header(self):
        self.print('# !!! THIS FILE IS GENERATED BY generate.py')
        self.print('# !!! DO NOT EDIT THIS FILE DIRECTLY')
        self.print()

    def english_list(self, parts: list[str]) -> str:
        if len(parts) == 0:
            return ''
        elif len(parts) == 1:
            return parts[0]
        elif len(parts) == 2:
            return f'{parts[0]} and {parts[1]}'
        else:
            return ', '.join(parts[:-1]) + f', and {parts[-1]}'

    def textwrap(self, text: str, width: int = 70, initial_indent: str | None = None, indent: str = '') -> typing.Iterator[str]:
        if initial_indent is None:
            initial_indent = indent
        width = 70 - self._indent
        lines = text.splitlines()
        for i, line in enumerate(lines):
            if line.strip():
                line = line.replace('\t', ' ')
                indent_amt = len(line) - len(line.lstrip())
                our_indent = ' ' * indent_amt + indent
                yield from textwrap.wrap(line, width=width, initial_indent=initial_indent, subsequent_indent=our_indent, break_long_words=False)
                initial_indent = indent
            else:
                yield ''

    def _markdown_to_rest(self, md: str) -> str:
        ast = commonmark.Parser().parse(md)
        rst = commonmark.ReStructuredTextRenderer().render(ast).strip()
        return rst

    def doc_string(self, doc: str | None, rest=False) -> None:
        if doc:
            if not rest:
                doc = self._markdown_to_rest(doc)
            lines = list(self.textwrap(doc, initial_indent='   ' * 3))
            for i, line in enumerate(lines):
                bare_repr = repr(line)[1:-1]
                if i == 0:
                    if len(lines) == 1:
                        self.print('"' * 3 + line.lstrip() + '"' * 3)
                    else:
                        self.print('"' * 3 + line.lstrip())
                else:
                    self.print(line)
            if len(lines) > 1:
                self.print('"' * 3)
            self.print()

    def doc_comment(self, doc: str | None, rest=False) -> None:
        if doc:
            if not rest:
                doc = self._markdown_to_rest(doc)
            lines = self.textwrap(doc, indent='#: ')
            for line in lines:
                self.print(line)

    def dunder_all(self, names: list[str]) -> None:
        name_inner = ' '.join(f'{n!r},' for n in names)
        width = 70 - self._indent
        lines = textwrap.wrap(name_inner, width=width)
        with self.print('__all__ = ['):
            for line in lines:
                self.print(line)
        self.print(']')
        self.print()
